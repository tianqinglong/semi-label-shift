{
apply(outMat, 1, function(y)
{
mean(exp(cbind(y, y^2) %*% matrix(betaRho, ncol = 1))*y)
}
) -> term1
apply(outMat, 1, function(y)
{
mean(exp(cbind(y, y^2) %*% matrix(betaRho, ncol = 1))*y^2)
}
) -> term2
out <- cbind(term1, term2)-matrix(e_t_log_e_beta, byrow = T, ncol = 2, nrow = nrow(outMat))
return(out)
}
Compute_S(beta_rho, yx, e_t_log_e_beta)
c_ps <- E_s_rho(beta_rho, s_samp)
tauVec <- Compute_tau(beta_rho, yx_all, dat, xn_s, c_ps)
source("g_c_1.R")
source("rej-sample.R")
source("fit_model.R")
source("evaluate.R")
n <- 200
m <- 300
mu <- c(0, 0, 0)
sigma <- diag(3)*0.8
beta <- c(1, 0.4, 0.4, 0.4, 0.5, 0.5)
sd <- 0.75
beta_rho <- c(-0.1, 0.05)
xn <- gen_x_marginal(1000, mu, sigma)
yn <- gen_y(xn, beta, sd)
max_out <- max_rho(yn, beta_rho)
ac_list <- rej_sample(yn, max_out)
t_samp <- make_target_sample(m, mu, sigma, beta, sd, beta_rho)
s_samp <- make_source_sample(n, mu, sigma, beta, sd, beta_rho)
dat <- s_samp
xn_s <- t_samp[,-1]
yxs <- gen_cond_y_given_x(dat, B = 200)
yxt <- gen_cond_y_given_t_x(dat, xn_s, B = 200)
yx_all <- as.matrix(rbind(yxs, yxt))
c_ps <- E_s_rho(beta_rho, dat)
e_t_log_rho_beta <- E_t_log_rho_beta(beta_rho, dat, c_ps)
tauVec <- Compute_tau(beta_rho, yx_all, dat, xn_s, c_ps)
sVec <- Compute_S(beta_rho, yx_all, e_t_log_e_beta)
tauVec
sVec
Compute_b1 <- function(betaRho, dat, xn_t, B=200)
{
n <- nrow(dat)
m <- nrow(xn_t)
p1 <- n/(n+m)
yxs <- gen_cond_y_given_x(dat, xn_t, B)
yxt <- gen_cond_y_given_t_x(dat, xn_t, B)
yx_all <- as.matrix(rbind(yxs, yxt))
c_ps <- E_s_rho(betaRho, dat)
e_t_log_rho_beta <- E_t_log_rho_beta(betaRho, dat, c_ps)
tauVec <- Compute_tau(betaRho, yx_all, dat, xn_t, c_ps)
sVec <- Compute_S(betaRho, yx_all, e_t_log_rho_beta)
e_t_tau <- E_t_tau(betaRho, yx_all, dat, xn_t)
e_t_tau_S <- c(mean(tauVec[-(1:n)]*sVec[-(1:n),1]),
mean(tauVec[-(1:n)]*sVec[-(1:n),2]))
term1 <- sVec-matrix(e_t_tau_S, byrow = T, ncol = 2, nrow = n+m)/(e_t_tau-1)
-(1-p1)*matrix(1-tauVec, ncol = 2, ncol = n+m)*term1
}
Compute_b1(beta_rho, dat, xn_s)
source('C:/Users/qltia/Dropbox/Tian_Qinglong/LabelShift/0-projects/4-semiparametric/Simulation/Code/evaluate.R')
Compute_b1(beta_rho, dat, xn_s)
source('C:/Users/qltia/Dropbox/Tian_Qinglong/LabelShift/0-projects/4-semiparametric/Simulation/Code/evaluate.R')
Compute_b1(beta_rho, dat, xn_s)
source('C:/Users/qltia/Dropbox/Tian_Qinglong/LabelShift/0-projects/4-semiparametric/Simulation/Code/evaluate.R')
Compute_b1(beta_rho, dat, xn_s)
Compute_b1 <- function(betaRho, dat, xn_t, B=200)
{
n <- nrow(dat)
m <- nrow(xn_t)
p1 <- n/(n+m)
yxs <- gen_cond_y_given_x(dat, B)
yxt <- gen_cond_y_given_t_x(dat, xn_t, B)
yx_all <- as.matrix(rbind(yxs, yxt))
c_ps <- E_s_rho(betaRho, dat)
e_t_log_rho_beta <- E_t_log_rho_beta(betaRho, dat, c_ps)
tauVec <- Compute_tau(betaRho, yx_all, dat, xn_t, c_ps)
sVec <- Compute_S(betaRho, yx_all, e_t_log_rho_beta)
e_t_tau <- E_t_tau(betaRho, yx_all, dat, xn_t, c_ps)
e_t_tau_S <- c(mean(tauVec[-(1:n)]*sVec[-(1:n),1]),
mean(tauVec[-(1:n)]*sVec[-(1:n),2]))
term1 <- sVec-matrix(e_t_tau_S, byrow = T, ncol = 2, nrow = n+m)/(e_t_tau-1)
-(1-p1)*matrix(1-tauVec, ncol = 2, nrow = n+m)*term1
}
Compute_b1(beta_rho, dat, xn_s)
# Generate sample of Y given X
gen_cond_y_given_x <- function(dat, B=200)
# dat is the source distribtion sample (x,y)
{
fout <- output_estimated_true(dat)
sd <- fout$Sigma
outMat <- matrix(rnorm(nrow(dat)*B, 0, sd), ncol = B)
outMat <- outMat+matrix(fout$Fitted, ncol = B, nrow = nrow(dat))
return(outMat)
}
gen_cond_y_given_t_x <- function(dat, xn, B=200)
{
fout <- output_estimated_true(dat)
sd <- fout$Sigma
Coef <- fout$Coef
fitted <- xn %*% matrix(Coef, ncol = 1)
outMat <- matrix(rnorm(nrow(xn)*B, 0, sd), ncol = B)
outMat <- outMat+matrix(fitted, ncol = B, nrow = nrow(xn))
return(outMat)
}
# Make ingredient
E_s_rho_x <- function(betaRho, outMat)
{
apply(outMat, 1, function(y)
{
yMat <- matrix(c(y, y^2), nrow = length(y)) %*% matrix(betaRho, ncol = 1)
mean(exp(yMat))
}
)
}
E_s_rho2_x <- function(betaRho, outMat)
{
apply(outMat, 1, function(y)
{
yMat <- cbind(y, y^2) %*% matrix(betaRho, ncol = 1)
mean(exp(2*yMat))
}
)
}
E_s_rho <- function(betaRho, dat)
# dat is the source distribtion sample (x,y)
{
yn <- dat[,"y"]
mean(exp(cbind(yn, yn^2) %*% matrix(betaRho, ncol = 1)))
}
Compute_tau <- function(betaRho, outMat, dat, xt, c_ps)
# dat: source dist;
# xt: x on the target dist;
{
n <- nrow(dat)
m <- nrow(xt)
p1 <- n/(n+m)
e_s_rho_x <- E_s_rho_x(betaRho, outMat)
e_s_rho2_x <- E_s_rho2_x(betaRho, outMat)
term1 <- e_s_rho2_x/e_s_rho_x/c_ps
tauOut <- term1/p1/(term1/p1+1/(1-p1))
return(tauOut)
}
E_t_tau <- function(betaRho, outMat, dat, xt, c_ps)
{
n <- nrow(dat)
tauOut <- Compute_tau(betaRho, outMat, dat, xt, c_ps)
return(mean(tauOut[-(1:n)]))
}
E_t_log_rho_beta <- function(betaRho, dat, c_ps)
{
yn <- dat[,"y"]
term0 <- exp(cbind(yn, yn^2) %*% matrix(betaRho, ncol = 1))
term1 <- mean(term0*yn)
term2 <- mean(term0*yn^2)
return(c(term1, term2)/c_ps)
}
Compute_S <- function(betaRho, outMat, e_t_log_e_beta)
{
apply(outMat, 1, function(y)
{
mean(exp(cbind(y, y^2) %*% matrix(betaRho, ncol = 1))*y)
}
) -> term1
apply(outMat, 1, function(y)
{
mean(exp(cbind(y, y^2) %*% matrix(betaRho, ncol = 1))*y^2)
}
) -> term2
out <- cbind(term1, term2)-matrix(e_t_log_e_beta, byrow = T, ncol = 2, nrow = nrow(outMat))
return(out)
}
S_eff_multiplier <- function(betaRho, n, m, yn, c_ps)
{
r <- c(rep(1, n), rep(0, m))
p1 <- n/(n+m)
rho_y <- exp(cbind(yn, yn^2)%*%matrix(betaRho, ncol = 1))
out <- c(1/p1*rho_y/c_ps, rep(-1/(1-p1), m))
out <- matrix(out, ncol = 2, nrow = n+m)
return(out)
}
Compute_S_eff <- function(betaRho, dat, xn_t, B=200)
{
n <- nrow(dat)
m <- nrow(xn_t)
p1 <- n/(n+m)
yxs <- gen_cond_y_given_x(dat, B)
yxt <- gen_cond_y_given_t_x(dat, xn_t, B)
yx_all <- as.matrix(rbind(yxs, yxt))
c_ps <- E_s_rho(betaRho, dat)
e_t_log_rho_beta <- E_t_log_rho_beta(betaRho, dat, c_ps)
tauVec <- Compute_tau(betaRho, yx_all, dat, xn_t, c_ps)
sVec <- Compute_S(betaRho, yx_all, e_t_log_rho_beta)
e_t_tau <- E_t_tau(betaRho, yx_all, dat, xn_t, c_ps)
e_t_tau_S <- c(mean(tauVec[-(1:n)]*sVec[-(1:n),1]),
mean(tauVec[-(1:n)]*sVec[-(1:n),2]))
term1 <- sVec-matrix(e_t_tau_S, byrow = T, ncol = 2, nrow = n+m)/(e_t_tau-1)
b1 <- -(1-p1)*matrix(1-tauVec, ncol = 2, nrow = n+m)*term1
s_eff_mult <- S_eff_multiplier(betaRho, n, m, dat[,"y"], c_ps)
return(s_eff_mult*b1)
}
Compute_S_eff(beta_rho, dat, xn_s)
colMeans(Compute_S_eff(beta_rho, dat, xn_s))
Compute_S_eff <- function(betaRho, dat, xn_t, yx_all)
{
colSums(Compute_S_eff_vec(betaRho, dat, xn_t, yx_all))
}
Compute_S_eff <- function(betaRho, dat, xn_t, yx_all)
{
sum(colMeans(Compute_S_eff_vec(betaRho, dat, xn_t, yx_all))^2)
}
source('C:/Users/qltia/Dropbox/Tian_Qinglong/LabelShift/0-projects/4-semiparametric/Simulation/Code/evaluate.R')
# Generate sample of Y given X
gen_cond_y_given_x <- function(dat, B=200)
# dat is the source distribtion sample (x,y)
{
fout <- output_estimated_true(dat)
sd <- fout$Sigma
outMat <- matrix(rnorm(nrow(dat)*B, 0, sd), ncol = B)
outMat <- outMat+matrix(fout$Fitted, ncol = B, nrow = nrow(dat))
return(outMat)
}
gen_cond_y_given_t_x <- function(dat, xn, B=200)
{
fout <- output_estimated_true(dat)
sd <- fout$Sigma
Coef <- fout$Coef
fitted <- xn %*% matrix(Coef, ncol = 1)
outMat <- matrix(rnorm(nrow(xn)*B, 0, sd), ncol = B)
outMat <- outMat+matrix(fitted, ncol = B, nrow = nrow(xn))
return(outMat)
}
# Make ingredient
E_s_rho_x <- function(betaRho, outMat)
{
apply(outMat, 1, function(y)
{
yMat <- matrix(c(y, y^2), nrow = length(y)) %*% matrix(betaRho, ncol = 1)
mean(exp(yMat))
}
)
}
E_s_rho2_x <- function(betaRho, outMat)
{
apply(outMat, 1, function(y)
{
yMat <- cbind(y, y^2) %*% matrix(betaRho, ncol = 1)
mean(exp(2*yMat))
}
)
}
E_s_rho <- function(betaRho, dat)
# dat is the source distribtion sample (x,y)
{
yn <- dat[,"y"]
mean(exp(cbind(yn, yn^2) %*% matrix(betaRho, ncol = 1)))
}
Compute_tau <- function(betaRho, outMat, dat, xt, c_ps)
# dat: source dist;
# xt: x on the target dist;
{
n <- nrow(dat)
m <- nrow(xt)
p1 <- n/(n+m)
e_s_rho_x <- E_s_rho_x(betaRho, outMat)
e_s_rho2_x <- E_s_rho2_x(betaRho, outMat)
term1 <- e_s_rho2_x/e_s_rho_x/c_ps
tauOut <- term1/p1/(term1/p1+1/(1-p1))
return(tauOut)
}
E_t_tau <- function(betaRho, outMat, dat, xt, c_ps)
{
n <- nrow(dat)
tauOut <- Compute_tau(betaRho, outMat, dat, xt, c_ps)
return(mean(tauOut[-(1:n)]))
}
E_t_log_rho_beta <- function(betaRho, dat, c_ps)
{
yn <- dat[,"y"]
term0 <- exp(cbind(yn, yn^2) %*% matrix(betaRho, ncol = 1))
term1 <- mean(term0*yn)
term2 <- mean(term0*yn^2)
return(c(term1, term2)/c_ps)
}
Compute_S <- function(betaRho, outMat, e_t_log_e_beta)
{
apply(outMat, 1, function(y)
{
mean(exp(cbind(y, y^2) %*% matrix(betaRho, ncol = 1))*y)
}
) -> term1
apply(outMat, 1, function(y)
{
mean(exp(cbind(y, y^2) %*% matrix(betaRho, ncol = 1))*y^2)
}
) -> term2
out <- cbind(term1, term2)-matrix(e_t_log_e_beta, byrow = T, ncol = 2, nrow = nrow(outMat))
return(out)
}
S_eff_multiplier <- function(betaRho, n, m, yn, c_ps)
{
r <- c(rep(1, n), rep(0, m))
p1 <- n/(n+m)
rho_y <- exp(cbind(yn, yn^2)%*%matrix(betaRho, ncol = 1))
out <- c(1/p1*rho_y/c_ps, rep(-1/(1-p1), m))
out <- matrix(out, ncol = 2, nrow = n+m)
return(out)
}
Generate_sampler <- function(dat, xn_t, B=200)
{
yxs <- gen_cond_y_given_x(dat, B)
yxt <- gen_cond_y_given_t_x(dat, xn_t, B)
yx_all <- as.matrix(rbind(yxs, yxt))
return(yx_all)
}
Compute_S_eff_vec <- function(betaRho, dat, xn_t, yx_all)
{
n <- nrow(dat)
m <- nrow(xn_t)
p1 <- n/(n+m)
c_ps <- E_s_rho(betaRho, dat)
e_t_log_rho_beta <- E_t_log_rho_beta(betaRho, dat, c_ps)
tauVec <- Compute_tau(betaRho, yx_all, dat, xn_t, c_ps)
sVec <- Compute_S(betaRho, yx_all, e_t_log_rho_beta)
e_t_tau <- E_t_tau(betaRho, yx_all, dat, xn_t, c_ps)
e_t_tau_S <- c(mean(tauVec[-(1:n)]*sVec[-(1:n),1]),
mean(tauVec[-(1:n)]*sVec[-(1:n),2]))
term1 <- sVec-matrix(e_t_tau_S, byrow = T, ncol = 2, nrow = n+m)/(e_t_tau-1)
b1 <- -(1-p1)*matrix(1-tauVec, ncol = 2, nrow = n+m)*term1
s_eff_mult <- S_eff_multiplier(betaRho, n, m, dat[,"y"], c_ps)
return(s_eff_mult*b1)
}
Compute_S_eff <- function(betaRho, dat, xn_t, yx_all)
{
sum(colMeans(Compute_S_eff_vec(betaRho, dat, xn_t, yx_all))^2)
}
optim(c(-0.1, 0.05), Compute_S_eff, dat = dat, xn_t = xn_s, yx_all = yx_all)
source("g_c_1.R")
source("rej-sample.R")
source("fit_model.R")
source("evaluate.R")
n <- 1000
m <- 500
mu <- c(0, 0, 0)
sigma <- diag(3)*0.8
beta <- c(1, 0.4, 0.4, 0.4, 0.5, 0.5)
sd <- 0.75
beta_rho <- c(-0.1, 0.05)
xn <- gen_x_marginal(1000, mu, sigma)
yn <- gen_y(xn, beta, sd)
max_out <- max_rho(yn, beta_rho)
ac_list <- rej_sample(yn, max_out)
t_samp <- make_target_sample(m, mu, sigma, beta, sd, beta_rho)
s_samp <- make_source_sample(n, mu, sigma, beta, sd, beta_rho)
dat <- s_samp
xn_s <- t_samp[,-1]
yxs <- gen_cond_y_given_x(dat, B = 200)
yxt <- gen_cond_y_given_t_x(dat, xn_s, B = 200)
yx_all <- as.matrix(rbind(yxs, yxt))
c_ps <- E_s_rho(beta_rho, dat)
e_t_log_rho_beta <- E_t_log_rho_beta(beta_rho, dat, c_ps)
tauVec <- Compute_tau(beta_rho, yx_all, dat, xn_s, c_ps)
sVec <- Compute_S(beta_rho, yx_all, e_t_log_e_beta)
yx_all <- Generate_sampler(dat, xn_s, B = 500)
optim(c(-0.1, 0.05), Compute_S_eff, dat = dat, xn_t = xn_s, yx_all = yx_all)
source("g_c_1.R")
source("rej-sample.R")
source("fit_model.R")
source("evaluate.R")
n <- 1000
m <- 500
mu <- c(0, 0, 0)
sigma <- diag(3)*0.8
beta <- c(1, 0.4, 0.4, 0.4, 0.5, 0.5)
sd <- 0.75
beta_rho <- c(-0.1, 0.05)
xn <- gen_x_marginal(1000, mu, sigma)
yn <- gen_y(xn, beta, sd)
max_out <- max_rho(yn, beta_rho)
ac_list <- rej_sample(yn, max_out)
t_samp <- make_target_sample(m, mu, sigma, beta, sd, beta_rho)
s_samp <- make_source_sample(n, mu, sigma, beta, sd, beta_rho)
dat <- s_samp
xn_s <- t_samp[,-1]
yxs <- gen_cond_y_given_x(dat, B = 200)
yxt <- gen_cond_y_given_t_x(dat, xn_s, B = 200)
yx_all <- as.matrix(rbind(yxs, yxt))
c_ps <- E_s_rho(beta_rho, dat)
e_t_log_rho_beta <- E_t_log_rho_beta(beta_rho, dat, c_ps)
tauVec <- Compute_tau(beta_rho, yx_all, dat, xn_s, c_ps)
sVec <- Compute_S(beta_rho, yx_all, e_t_log_e_beta)
yx_all <- Generate_sampler(dat, xn_s, B = 500)
optim(c(0, 0.05), Compute_S_eff, dat = dat, xn_t = xn_s, yx_all = yx_all)
source("g_c_1.R")
source("rej-sample.R")
source("fit_model.R")
source("evaluate.R")
n <- 1000
m <- 500
mu <- c(0, 0, 0)
sigma <- diag(3)*0.8
beta <- c(1, 0.4, 0.4, 0.4, 0.5, 0.5)
sd <- 0.75
beta_rho <- c(-0.1, 0.05)
xn <- gen_x_marginal(1000, mu, sigma)
yn <- gen_y(xn, beta, sd)
max_out <- max_rho(yn, beta_rho)
ac_list <- rej_sample(yn, max_out)
t_samp <- make_target_sample(m, mu, sigma, beta, sd, beta_rho)
s_samp <- make_source_sample(n, mu, sigma, beta, sd, beta_rho)
dat <- s_samp
xn_s <- t_samp[,-1]
yxs <- gen_cond_y_given_x(dat, B = 200)
yxt <- gen_cond_y_given_t_x(dat, xn_s, B = 200)
yx_all <- as.matrix(rbind(yxs, yxt))
c_ps <- E_s_rho(beta_rho, dat)
e_t_log_rho_beta <- E_t_log_rho_beta(beta_rho, dat, c_ps)
tauVec <- Compute_tau(beta_rho, yx_all, dat, xn_s, c_ps)
sVec <- Compute_S(beta_rho, yx_all, e_t_log_e_beta)
yx_all <- Generate_sampler(dat, xn_s, B = 1000)
optim(c(0, 0.05), Compute_S_eff, dat = dat, xn_t = xn_s, yx_all = yx_all)
Compute_beta_var <- function(betaRho, dat, xn_t, yx_all)
{
n <- nrow(dat)
m <- nrow(xn_t)
p1 <- n/(n+m)
c_ps <- E_s_rho(betaRho, dat)
e_t_log_rho_beta <- E_t_log_rho_beta(betaRho, dat, c_ps)
e_s_rho_x <- E_s_rho_x(betaRho, yx_all)
tauVec <- Compute_tau(betaRho, yx_all, dat, xn_t, c_ps, e_s_rho_x)
sVec <- Compute_S(betaRho, yx_all, e_t_log_rho_beta, e_s_rho_x)
e_t_tau <- E_t_tau(betaRho, yx_all, dat, xn_t, c_ps, e_s_rho_x)
e_t_tau_S <- c(
mean(tauVec[-(1:n)]*sVec[-(1:n),1]),
mean(tauVec[-(1:n)]*sVec[-(1:n),2])
)
term1 <- sVec-matrix(e_t_tau_S, byrow = T, ncol = 2, nrow = n+m)/(e_t_tau-1)
SST <- matrix(0, nrow = length(betaRho), ncol = length(betaRho))
for (i in (n+1):(n+m))
{
vec <- term1[i,]
tempMat <- matrix(vec, nrow = 2, ncol = 1) %*% matrix(vec, nrow = 1, ncol = 2)
tempMat <- tempMat*tauVec[i]*(1-p1)
SST <- SST+tempMat
}
SST <- SST/m
return(SST)
}
source("g_c_1.R")
source("rej-sample.R")
source("fit_model.R")
source("evaluate.R")
n <- 1000
m <- 500
mu <- c(0, 0, 0)
sigma <- diag(3)*0.8
beta <- c(1, 0.4, 0.4, 0.4, 0.5, 0.5)
sd <- 0.75
beta_rho <- c(-0.1, 0.05)
xn <- gen_x_marginal(1000, mu, sigma)
yn <- gen_y(xn, beta, sd)
max_out <- max_rho(yn, beta_rho)
ac_list <- rej_sample(yn, max_out)
t_samp <- make_target_sample(m, mu, sigma, beta, sd, beta_rho)
s_samp <- make_source_sample(n, mu, sigma, beta, sd, beta_rho)
dat <- s_samp
xn_s <- t_samp[,-1]
yxs <- gen_cond_y_given_x(dat, B = 200)
yxt <- gen_cond_y_given_t_x(dat, xn_s, B = 200)
yx_all <- as.matrix(rbind(yxs, yxt))
c_ps <- E_s_rho(beta_rho, dat)
e_t_log_rho_beta <- E_t_log_rho_beta(beta_rho, dat, c_ps)
tauVec <- Compute_tau(beta_rho, yx_all, dat, xn_s, c_ps)
sVec <- Compute_S(beta_rho, yx_all, e_t_log_e_beta)
yx_all <- Generate_sampler(dat, xn_s, B = 1000)
source("g_c_1.R")
source("rej-sample.R")
source("fit_model.R")
source("evaluate.R")
n <- 1000
m <- 500
mu <- c(0, 0, 0)
sigma <- diag(3)*0.8
beta <- c(1, 0.4, 0.4, 0.4, 0.5, 0.5)
sd <- 0.75
beta_rho <- c(-0.1, 0.05)
xn <- gen_x_marginal(1000, mu, sigma)
yn <- gen_y(xn, beta, sd)
max_out <- max_rho(yn, beta_rho)
ac_list <- rej_sample(yn, max_out)
t_samp <- make_target_sample(m, mu, sigma, beta, sd, beta_rho)
s_samp <- make_source_sample(n, mu, sigma, beta, sd, beta_rho)
dat <- s_samp
xn_s <- t_samp[,-1]
yx_all <- Generate_sampler(dat, xn_s, B = 1000)
Compute_beta_var(beta_rho, dat, xn_t, yx_all)
dat <- s_samp
xn_t <- t_samp[,-1]
yx_all <- Generate_sampler(dat, xn_t, B = 1000)
Compute_beta_var(beta_rho, dat, xn_t, yx_all)
solve(Compute_beta_var(beta_rho, dat, xn_t, yx_all)
)
optim(c(0, 0.05), Compute_S_eff, dat = dat, xn_t = xn_s, yx_all = yx_all)
Compute_beta_var(beta_rho, dat, xn_t, yx_all)
foptim <- optim(c(0, 0.05), Compute_S_eff, dat = dat, xn_t = xn_s, yx_all = yx_all)
Compute_beta_var(foptim$par, dat, xn_t, yx_all)
ESS <- Compute_beta_var(foptim$par, dat, xn_t, yx_all)
solve(ESS)
